# -*- coding: utf-8 -*-
"""Deduplication of BATH tbl output

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hOk5dtuVBu404dEP1aTxC2IbPZDjsFHY
"""

input_filepath = '/content/drive/MyDrive/Lab Work/Syed Data/BATH Outputs/DNA_Mitochondria_kingdom_sprot_ctcombined_sorted_data.tbl'
output_filepath = 'DNA_Mitochondria_kingdom_sprot_ctcombined_deduplicated.tbl'

def compare_contig_names(original_contigs, positive_strand, negative_strand):
    # Create sets of contig names for easier comparison
    original_contig_names = set(original_contigs.keys())
    positive_strand_names = set(positive_strand.keys())
    negative_strand_names = set(negative_strand.keys())

    # Check for contig names present in all dictionaries
    in_all_three = original_contig_names.intersection(positive_strand_names, negative_strand_names)

    # Print results
    print("Contig names in all three dictionaries:")
    print(len(in_all_three))
    for contig_name in in_all_three:
        print(contig_name)

    # Additional information: contig names unique to each dictionary
    unique_to_original = original_contig_names - (positive_strand_names.union(negative_strand_names))
    unique_to_positive = positive_strand_names - (negative_strand_names)
    unique_to_negative = negative_strand_names - (positive_strand_names)

    if unique_to_original:
        print("\nContig names unique to original contigs:")
        for contig_name in unique_to_original:
            print(contig_name)
            print(len(contig_name))

    if unique_to_positive:
        print("\nContig names unique to positive strand (not neg):")
        print(len(unique_to_positive))
        for contig_name in unique_to_positive:
            print(contig_name)

    if unique_to_negative:
        print("\nContig names unique to negative strand (not pos):")
        print(len(unique_to_negative))
        for contig_name in unique_to_negative:
            print(contig_name)

def count_total_entries(contigs):
    total_entries = 0
    for target_name in contigs:
        total_entries += len(contigs[target_name])
    return total_entries

def process_file(filepath):
    contigs = {}
    header_lines = []
    count = 0

    with open(filepath, 'r') as file:
        lines = file.readlines()

    header_lines = [line for line in lines if line.startswith('#')]
    data_lines = [line for line in lines if not line.startswith('#') and line.strip()]

    for line in data_lines:
        count += 1
        parts = line.split()

        if len(parts) < 18:
            continue

        target_name = parts[0]
        ali_from = int(parts[8])
        ali_to = int(parts[9])
        e_value = float(parts[12])

        if target_name not in contigs:
            contigs[target_name] = []

        contigs[target_name].append({
            'ali_from': ali_from,
            'ali_to': ali_to,
            'e_value': e_value,
            'full_line': line.strip()
        })

    # Sorting each contig's entries
    for target_name in contigs:
        contigs[target_name] = sorted(contigs[target_name], key=lambda x: (x['ali_from'], x['ali_to']))

    # Sorting contigs by name
    contigs = dict(sorted(contigs.items()))

    print("Original File Length", count)
    print("Contig Length:", len(contigs))
    print("Contig Value Entry Length:", count_total_entries(contigs))
    return contigs, header_lines

def find_pos_neg_strand(contigs):
    positive_strand = {}
    negative_strand = {}

    for target_name in contigs:
        for entry in contigs[target_name]:
            # Assuming positive strand is when 'ali_from' is less than or equal to 'ali_to'
            if entry['ali_from'] <= entry['ali_to']:
                if target_name not in positive_strand:
                    positive_strand[target_name] = []
                positive_strand[target_name].append(entry)
            # Assuming negative strand is when 'ali_from' is greater than 'ali_to'
            else:
                if target_name not in negative_strand:
                    negative_strand[target_name] = []
                negative_strand[target_name].append(entry)

    # Sorting the positive strand by 'ali_from'
    for target_name in positive_strand:
        positive_strand[target_name] = sorted(positive_strand[target_name], key=lambda x: x['ali_from'])

    # Sorting the negative strand by 'ali_to'
    for target_name in negative_strand:
        negative_strand[target_name] = sorted(negative_strand[target_name], key=lambda x: x['ali_to'], reverse=True)

    print('Contigs after Positive, Negative strand division: ', len(positive_strand) + len(negative_strand))
    return positive_strand, negative_strand


def calculate_overlap(start1, end1, start2, end2):
    overlap = max(0, min(end1, end2) - max(start1, start2))
    #print(overlap)
    total_length = min(end1 - start1, end2 - start2)
    #print(total_length)
    return overlap / total_length if total_length > 0 else 0

def calculate_overlap_negative_strand(start1, end1, start2, end2):
    overlap_start = max(end1, end2)
    overlap_end = min(start1, start2)
    overlap = max(0, overlap_end - overlap_start)
    total_length = min(start1 - end1, start2 - end2)

    # Debugging print statements
    #print(f"Comparing intervals: ({end1}, {start1}) and ({end2}, {start2})")
    #print(f"Overlap start: {overlap_start}, Overlap end: {overlap_end}, Overlap: {overlap}, Total length: {total_length}")

    return overlap / total_length if total_length > 0 else 0


def add_entry_to_dict(dictionary, target_name, entry):
    if target_name not in dictionary:
        dictionary[target_name] = []
    dictionary[target_name].append(entry)

def update_alignments(contig_dict, target_name, i, j, overlap_below_70_old_discard, overlap_below_70_updated_add, update_first_alignment):
    align1 = contig_dict[target_name][i]
    align2 = contig_dict[target_name][j]
    updated_alignment = None  # Initialize to None

    if update_first_alignment:
        # Update align1 based on align2's position
        updated_align1 = align1.copy()
        if align2['ali_from'] > align1['ali_from']:
            updated_align1['ali_from'] = align2['ali_to'] + 1
            contig_dict[target_name][i] = updated_align1
        elif align2['ali_from'] < align1['ali_to']:
            updated_align1['ali_to'] = align2['ali_from'] - 1
            contig_dict[target_name][i] = updated_align1

        updated_alignment = updated_align1

    else:
        # Update align2 based on align1's position
        updated_align2 = align2.copy()
        if align1['ali_to'] > align2['ali_from']:
            updated_align2['ali_to'] = align1['ali_from'] - 1
            contig_dict[target_name][j] = updated_align2
        elif align1['ali_from'] < align2['ali_to']:
            updated_align2['ali_from'] = align1['ali_to'] + 1
            contig_dict[target_name][j] = updated_align2

        updated_alignment = updated_align2

    if updated_alignment:
        add_entry_to_dict(overlap_below_70_old_discard, target_name, align1 if update_first_alignment else align2)
        add_entry_to_dict(overlap_below_70_updated_add, target_name, updated_alignment)

    # Optional debug prints
    # print("Updated Alignment: ", updated_alignment['ali_from'], '\t', updated_alignment['ali_to'], '\t', updated_alignment['e_value'])

    # Optional debug prints
    print("Final entry values:")
    print("Flag: update_first_alignment", update_first_alignment)
    print("Alignment 1: ", contig_dict[target_name][i]['ali_from'], '\t', contig_dict[target_name][i]['ali_to'], '\t', contig_dict[target_name][i]['e_value'])
    print("Alignment 2: ", contig_dict[target_name][j]['ali_from'], '\t', contig_dict[target_name][j]['ali_to'], '\t', contig_dict[target_name][j]['e_value'])

import json

def save_dict_to_json(contig_dict, filename):
    # Convert the dictionary to a JSON string
    json_string = json.dumps(contig_dict, indent=4)

    # Write the JSON string to a file
    with open(filename, 'w') as file:
        file.write(json_string)

'''
def deduplication_logic2(contig_dict, is_positive):
    overlap_above_70_keep = {}
    overlap_above_70_discard = {}
    overlap_below_70_updated_add = {}
    overlap_below_70_old_discard = {}

    if is_positive:
      for target_name in list(contig_dict.keys()):
        i = 0
        while i < len(contig_dict[target_name]):
          align1 = contig_dict[target_name][i]
          j = i + 1
          while j < len(contig_dict[target_name]):
            align2 = contig_dict[target_name][j]
            overlap = calculate_overlap(align1['ali_from'], align1['ali_to'], align2['ali_from'], align2['ali_to'])

            if overlap >= 0.7:
                if align1['e_value'] > align2['e_value']:
                    # Keep align2 in contig_dict
                    # Discard align1 from contig_dict
                    add_entry_to_dict(overlap_above_70_discard, target_name, align1)
                    contig_dict[target_name].pop(i)
                    # No need to increment i, as the next element shifts to the current position
                    # Break out of the inner loop since align1 is removed
                    break
                elif align1['e_value'] <= align2['e_value']:
                    # Keep align1 in contig_dict
                    # Discard align2 from contig_dict
                    add_entry_to_dict(overlap_above_70_discard, target_name, align2)
                    contig_dict[target_name].pop(j)
                    # Continue with the next comparison
                    # j is incremented in the loop no need for an additional increment here
                    continue

            elif 0.1< overlap < 0.7:
              if align1['e_value'] > align2['e_value']:
                print("\nCase where align2 is best hit, so update align1")
                update_alignments(contig_dict, target_name, i, j, overlap_below_70_old_discard, overlap_below_70_updated_add, True)  # Update align1
              else:
                print("\nCase where align1 is best hit, so update align2")
                update_alignments(contig_dict, target_name, i, j, overlap_below_70_old_discard, overlap_below_70_updated_add, False)  # Update align2

            j+=1
          i+=1

    else:
      # Negative Strand Processing

      for target_name in list(contig_dict.keys()):
          i = 0
          while i < len(contig_dict[target_name]):
              align1 = contig_dict[target_name][i]
              alignment_removed = False
              j = i + 1
              while j < len(contig_dict[target_name]):
                  align2 = contig_dict[target_name][j]
                  overlap = calculate_overlap_negative_strand(align1['ali_from'], align1['ali_to'], align2['ali_from'], align2['ali_to'])

                  if overlap > 0.7:
                    if align1['e_value'] > align2['e_value']:
                        add_entry_to_dict(overlap_above_70_discard, target_name, align1)
                        contig_dict[target_name].pop(i)
                        alignment_removed = True
                        break
                    elif align1['e_value'] <= align2['e_value']:
                        add_entry_to_dict(overlap_above_70_discard, target_name, align2)
                        contig_dict[target_name].pop(j)
                        continue
                      # Add logic here for case when align1['e_value'] == align2['e_value']

                  elif 0.1< overlap < 0.7:
                    if align1['e_value'] > align2['e_value']:
                      print("\nCase where align2 is best hit, so update align1")
                      update_alignments(contig_dict, target_name, i, j, overlap_below_70_old_discard, overlap_below_70_updated_add, True)  # Update align1
                    else:
                      print("\nCase where align1 is best hit, so update align2")
                      update_alignments(contig_dict, target_name, i, j, overlap_below_70_old_discard, overlap_below_70_updated_add, False)  # Update align2


                  j += 1
              if not alignment_removed:
                  i += 1



    return contig_dict, overlap_above_70_discard
'''

def count_alignments_in_file(file_path):
    try:
        with open(file_path, 'r') as file:
            data = json.load(file)

        # Count the number of alignments for each contig
        contig_counts = {contig: len(alignments) for contig, alignments in data.items()}

        # Calculate the total number of alignments across all contigs
        total_alignments = sum(contig_counts.values())

        return contig_counts, total_alignments

    except Exception as e:
        print(f"An error occurred: {e}")
        return {}, 0

def deduplication_logic2(contig_dict, is_positive):
    overlap_above_70_keep = {}
    overlap_above_70_discard = {}
    overlap_below_70_updated_add = {}
    overlap_below_70_old_discard = {}

    for target_name in contig_dict:
        i = 0
        while i < len(contig_dict[target_name]):
            align1 = contig_dict[target_name][i]
            j = i + 1
            while j < len(contig_dict[target_name]):
                align2 = contig_dict[target_name][j]
                overlap = (calculate_overlap if is_positive else calculate_overlap_negative_strand)(
                    align1['ali_from'], align1['ali_to'], align2['ali_from'], align2['ali_to']
                )

                if overlap > 0.7:
                  if align1['e_value'] > align2['e_value']:
                      # Keep align2 in contig_dict
                      # Discard align1 from contig_dict
                      add_entry_to_dict(overlap_above_70_discard, target_name, align1)
                      contig_dict[target_name].pop(i)
                      # No need to increment i, as the next element shifts to the current position
                      # Break out of the inner loop since align1 is removed
                      break
                  elif align1['e_value'] <= align2['e_value']:
                      # Keep align1 in contig_dict
                      # Discard align2 from contig_dict
                      add_entry_to_dict(overlap_above_70_discard, target_name, align2)
                      contig_dict[target_name].pop(j)
                      # Continue with the next comparison
                      # j is incremented in the loop no need for an additional increment here
                      continue
                elif 0.1 < overlap < 0.7:
                    print(f"Moderate overlap detected between: {align1['full_line']} and {align2['full_line']}, Overlap: {overlap}")
                    if align1['e_value'] > align2['e_value']:
                      print("\nCase where align2 is best hit, so update align1")
                      update_alignments(contig_dict, target_name, i, j, overlap_below_70_old_discard, overlap_below_70_updated_add, True)  # Update align1
                    else:
                      print("\nCase where align1 is best hit, so update align2")
                      update_alignments(contig_dict, target_name, i, j, overlap_below_70_old_discard, overlap_below_70_updated_add, False)  # Update align2


                j += 1
            i += 1

    return contig_dict, overlap_above_70_discard

contigs, header = process_file(input_filepath)

positive_strand, negative_strand = find_pos_neg_strand(contigs)

compare_contig_names(contigs, positive_strand, negative_strand)

save_dict_to_json(contigs, 'all_contigs.json')

contig_neg, discard_neg = deduplication_logic2(negative_strand,is_positive=False)

count_total_entries(contig_neg)

save_dict_to_json(contig_neg, 'negative_strand.json')

contig_pos, discard_pos = deduplication_logic2(positive_strand,is_positive=True)

count_total_entries(contig_pos)

save_dict_to_json(contig_pos, 'positive_strand.json')

#Negative Strand Test Data
test_data = {
    "k127_486726": [
        {
            "ali_from": 96445,
            "ali_to": 96056,
            "e_value": 0.0073,
            "full_line": "k127_486726 - O63852 - 982 708 836 181032 96445 96056 96451 95954 0.0073 18.3 0.0 0 0 std - ct22"
        },
        {
            "ali_from": 96496,
            "ali_to": 96056,
            "e_value": 3.4e-06,
            "full_line": "k127_486726 - O63852 - 982 691 836 181032 96496 96056 96535 95954 3.4e-06 29.3 0.1 0 0 std - ct23"
        }
    ],
    "k127_533492": [
        {
            "ali_from": 108542,
            "ali_to": 107874,
            "e_value": 0.0013,
            "full_line": "k127_533492 - B0FWD3 - 580 10 236 131788 108542 107874 108567 107704 0.0013 28.4 0.0 5 0 fs - ct14"
        },
        {
            "ali_from": 108295,
            "ali_to": 107862,
            "e_value": 0.21,
            "full_line": "k127_533492 - Q31696 - 265 95 240 131788 108295 107862 108347 107805 0.21 23.5 0.0 2 0 fs - ct14"
        }
    ],
    "k127_748425": [
        {
            "ali_from": 33640,
            "ali_to": 33255,
            "e_value": 0.18,
            "full_line": "k127_748425 - P0DKY8 - 187 7 135 125518 33640 33255 33664 33209 0.18 24.5 0.0 7 0 fs - ct13"
        },
        {
            "ali_from": 33640,
            "ali_to": 33252,
            "e_value": 0.027,
            "full_line": "k127_748425 - P0DKY8 - 187 7 136 125518 33640 33252 33664 33220 0.027 27.1 0.0 4 0 fs - ct3"
        }
    ]
}

"""## Analysis"""

count_alignments_in_file("/content/negative_strand.json")

count_alignments_in_file("/content/positive_strand.json")

count_alignments_in_file("//content/all_contigs.json")

